## 접근제어자
Java에서는 접근제어자를 통해 클래스, 필드, 메서드 등에 대한 접근 권한을 가짐
접근제어자에는 크게 4가지가 있다
- private
- protected
- public
- default
-----
#### private
private 제어자는 해당 멤버를 선언한 클래스 내에서만 접근할 수 있도록 제한함   
외부 클래스나 인스턴스에서는 접근 불가 -> 해당 클래스 내부 구현에서만 사용
-----
#### public
public 제어자는 모든 클래스에서 접근 가능   
해당 멤버가 외부에서 자주 사용되거나, 외부에 노출되어도 문제가 없을 경우 사용   
같은 패키지 뿐만 아니라 다른 패키지에서도 자유롭게 사용
-----
#### protected
protected 제어자는 같은 패키지 또는 자식 클래스에서 사용
dafault와 마찬가지로 같은 패키지에서는 사용할 수 있지만   
다른 패키지에 속한 클래스가 해당 클래스를 상속 받는다면, 즉 자식 클래스라면 호출 가능
-----
#### default
클래스를 선언할 때 public을 생략했다면 자동으로 default 접근 제한을 가짐   
같은 패키지에서는 아무런 제한 없이 사용할 수 있지만 다른 패키지에서는 사용 불가
-----
#### 로직을 감춰야 하는 이유
사용자와 직접적으로 대화를 해야하는 객체를 제외하면 굳이 공개할 필요가 없음   
로직의 동작과 흐름을 외부에 공개하는 것은 불안정하고 위험   
중단되거나 다른 외부에서 호출 시 다른 기능에 영향을 끼칠 위험성 존재   
##### 따라서 세부적인 로직은 이를 수행시켜주는 객체와 함수끼리만 소통하게 제한
사용자와 직접 소통을 하는 trigger 역할을 하는 큰 함수는 public으로 공개   
내부에서 서로 대화하는 작은 단위의 함수들은 private으로 감춤
-----
#### test의 경우
private 함수는 test를 지양해야 함   
private의 의도가 내부를 감추어 결합도를 낮추는 것 -> test 클래스가 내부 메소드에 접근하면 의도가 상실됨   
private test를 지원하는 라이브러리도 존재하고, 임의로 public으로 감싸는 방법도 있지만 지양해야 함   
외부에 공개하지 않고, 역할을 제한해서 사용되어야 하는 것을 억지로 드러내서 사용하는 격   
public 함수 test 시 통과가 되었다면, 해당 함수에 포함되어 있는 private도 대게 문제가 없음   
   
##### 결론
- private 메소드의 test는 본질을 해치며 결합도가 높아지고 깨지기 쉬움
- 이는 유지보수할 때 테스트의 비용을 증가시키는 요인
- public 함수 test 통과 시, 사용된 private도 함께 통과되었다고 판단
- 따라서 private 메소드를 test 해야하는 상황까지 왔다면 어딘가 설계가 잘못되었다는 뜻